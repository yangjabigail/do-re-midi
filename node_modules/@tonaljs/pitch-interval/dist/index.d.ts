import { Pitch, NamedPitch, Direction, IntervalCoordinates, PitchCoordinates } from '@tonaljs/pitch';

type IntervalName = string;
type IntervalLiteral = IntervalName | Pitch | NamedPitch;
type Quality = "dddd" | "ddd" | "dd" | "d" | "m" | "M" | "P" | "A" | "AA" | "AAA" | "AAAA";
type Type = "perfectable" | "majorable";
interface Interval extends Pitch, NamedPitch {
    readonly empty: boolean;
    readonly name: IntervalName;
    readonly num: number;
    readonly q: Quality;
    readonly type: Type;
    readonly step: number;
    readonly alt: number;
    readonly dir: Direction;
    readonly simple: number;
    readonly semitones: number;
    readonly chroma: number;
    readonly coord: IntervalCoordinates;
    readonly oct: number;
}
type IntervalTokens = [string, string];
/**
 * @private
 */
declare function tokenizeInterval(str?: IntervalName): IntervalTokens;
/**
 * Get interval properties. It returns an object with:
 *
 * - name: the interval name
 * - num: the interval number
 * - type: 'perfectable' or 'majorable'
 * - q: the interval quality (d, m, M, A)
 * - dir: interval direction (1 ascending, -1 descending)
 * - simple: the simplified number
 * - semitones: the size in semitones
 * - chroma: the interval chroma
 *
 * @param {string} interval - the interval name
 * @return {Object} the interval properties
 *
 * @example
 * import { interval } from '@tonaljs/core'
 * interval('P5').semitones // => 7
 * interval('m3').type // => 'majorable'
 */
declare function interval(src: IntervalLiteral): Interval;
/**
 * @private
 *
 * forceDescending is used in the case of unison (#243)
 */
declare function coordToInterval(coord: PitchCoordinates, forceDescending?: boolean): Interval;

export { type Interval, type IntervalLiteral, type IntervalName, coordToInterval, interval, tokenizeInterval };
